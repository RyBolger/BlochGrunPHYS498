import numpy as np
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
import scipy.integrate as integrate 
import math

data = np.loadtxt('0T.txt')
temp = data[:, 0]
res = data[:, 1]
t = list(temp)
Res = list(res)



def Bloch(temp, alpha1, theta_r, theta_e, res0, resee, resEin):
    ydata = []
    n = 5
    for i in range (len(temp)):
        #def resee(temp, A):
        #   return A*temp[i]**2
        lower, upper = 0, theta_r/temp[i]
        x = lambda t: (t**(n))/((math.exp(t)-1) * (1-math.exp(-t)) + res0 + resee + resEin)
        integral, error = integrate.quad(x,lower,upper)
        ydata.append(((alpha1*(temp[i]/theta_r)**n) * integral) + res0 + resee + resEin)
    return ydata
    
#estimate the parameters

alpha1 = 7*10**-4
theta_r = 160
res0 = 4.4*10**-9
A = 1.4*10**-13
KNM = 10*10**-7
theta_e = 70

def resee(temp, A):
    return A * (np.average(temp))**2
#1.3*10**-10
def resEin (temp, KNM):
    return (KNM/np.average(temp)) * (1 / ((math.exp(theta_e/np.average(temp))-1) * (1-math.exp(-theta_e/np.average(temp)))))
#use curve fit to output optimised parameters into popt 

popt, pcov = curve_fit(Bloch, temp, res, p0=[alpha1,theta_r, theta_e, res0, A, KNM])
alpha1, theta_r, theta_e, res0, A, KNM = popt

#plotting experimental, estimated parameter and fitted data

plt.figure()
plt.xlabel("Temperature [K]")
plt.ylabel("Resistivity [$\Omega$]")
plt.title("Fitting the Bloch Gruneisen function to the experimental data to obtain the parameters", pad=20)
plt.plot(temp, res, 'k.', ms=0.5, label='data')
plt.plot(temp, Bloch(temp, *popt),'r.', ms=0.5, label='fitted parameters')
plt.legend(bbox_to_anchor=(1.05, 1), loc='best', borderaxespad=0.)
