import numpy as np
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
import scipy.integrate as integrate 
import math

data = np.loadtxt('0T.txt')
temp = data[:, 0]
res = data[:, 1]


t = list(temp)
Res = list(res)


#plt.plot(t, Res, '.', ms=1)


ydata = []
dydata =[]
lim = 0.01

#define the BG function with all the parameters listed
def fun(t, n, A, T, theta_r):
    ydata = []
    dydata = []
    lim = 0.01
    x2 = lambda t: (t**(n))/((math.exp(t)-1) * (1-math.exp(-t)))
#using the BG function to generate ydata
    while lim <= theta_r:
        I = integrate.quad(x2, 0, lim)
        ydata.append(A*(T/theta_r)**n * I[0])
        dydata.append(A*(T/theta_r)**n * I[1])
        lim += theta_r/len(t)
        return ydata

#define data to be fit with some noise:
xdata = np.linspace(0, 300, 2971)
y = fun(xdata, 3, 7*10**-4, 300, 230)
np.random.seed(1729)
y_noise = (2*10**-7) * np.random.normal(size=temp.size)
yData = y + y_noise
plt.plot(temp, yData, 'b.', label='data')

#fit for the parameters a,b,c of function fun:
popt, pcov = curve_fit(fun, temp, yData)
popt

plt.plot(temp, fun(temp, *popt), 'r-', label='fit: a=%5.3f, b=%5.3f, c=%5.3f' %tuple(popt))
#adding contraints to the region
popt, pcov = curve_fit(fun, temp, yData, bounds=(0,[5., (7*10**-4), 300., 230])) 
popt

plt.plot(temp, fun(temp, *popt), 'g--', label='fit: a=%5.3f, b=%5.3f, c=%5.3f' %tuple(popt))

plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.show()
