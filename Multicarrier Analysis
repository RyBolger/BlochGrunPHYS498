import sympy as sp
from sympy.functions import *
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt 
import math
import symfit
from symfit import Variable, Parameter, parameters, Fit, Model, exp, cosh, DiracDelta, CallableNumericalModel
from symfit.contrib.interactive_guess import InteractiveGuess
import numpy as np
plt.ion()

data = np.loadtxt('PdSn4_010K_rhoData.txt')
xdata = np.array(data[:, 0])
rhoxx_exp = np.array(data[:, 1])
rhoxy_exp = np.array(data[:, 2])


def sigxy(B,n,mu):
    ydata = []   
    q = 1.6e-19
    R = -1 / (q*n)
    rho = 1 / (abs(n) * q * mu)
    for i in range (len(B)):
        ydata.append( - (R * B[i]) / (rho**2 + (R*B[i])**2) )
    return np.array(ydata)

def sigxx(B,n,mu):
    ydata = []   
    q = 1.6e-19
    R = -1 / (q*n)
    rho = 1 / (abs(n) * q * mu)
    for i in range (len(B)):
        ydata.append( rho / (rho**2 + (R*B[i])**2) )
    return np.array(ydata)


n1, n2 = 1.51e27, -1.519e27
mu1, mu2 = 1.41, 0.64

sigxy1 = sigxy(xdata, n1, mu1)
sigxy2 = sigxy(xdata, n2, mu2)
sigxy = (sigxy1 + sigxy2)

sigxx1 = sigxx(xdata, n1, mu1)
sigxx2 = sigxx(xdata, n2, mu2)
sigxx = (sigxx1 + sigxx2)

rhoxx = sigxx / (sigxx**2 + sigxy**2)
rhoxy = - sigxy / (sigxx**2 + sigxy**2)

def IIS(B,a,f):
    ydata = []    
    for i in range (len(B)):
        ydata.append( a / (sp.cosh(B[i]/f)) )
    return np.array(ydata)


a = 1.1513
f = 0.992

#IIS magnetoresistance contribution
rho_IIS = rhoxx * IIS(xdata,a,f)

#total longitudinal magnetoresistance
rhoxx_tot = rhoxx + rho_IIS


B = Variable('B')
y1 = Variable('y1')
y2 = Variable('y2')
n_1 = Parameter('n1', value=n1, min=1.5e27, max=1.55e27) 
n_2 = Parameter('n2', value=n2, min=-1.52e27, max=-1.51e27)
mu_1 = Parameter('mu1', value=mu1, min=1.4, max=1.42)
mu_2 = Parameter('mu2', value=mu2, min=0.63, max=0.65)

a = 1.1513
f = 0.992
q = 1.6e-19

R1 = -1 / (q*n_1)
R2 = -1 / (q*n_2)

rho1 = 1 / (abs(n_1) * q * mu_1)   
rho2 = 1 / (abs(n_2) * q * mu_2)


dictionary = ({

    y1: lambda B,n1,n2,mu1,mu2: 
    
      (rho1 / (rho1**2 + (R1*B)**2) + rho2 / (rho2**2 + (R2*B)**2)) 
    
    / ((rho1 / (rho1**2 + (R1*B)**2) + rho2 / (rho2**2 + (R2*B)**2))**2)
       
       + ((-R1*B)/(rho1**2+(R1*B)**2) + (-R2*B)/(rho2**2+(R2*B)**2))
    
    + (a/((exp(B/f)+exp(-B/f))/2)*((rho1 / (rho1**2 + (R1*B)**2) + rho2 / (rho2**2 + (R2*B)**2)) 
    
    / ((rho1 / (rho1**2 + (R1*B)**2) + rho2 / (rho2**2 + (R2*B)**2))**2
       
       + ((-R1*B)/(rho1**2+(R1*B)**2) + (-R2*B)/(rho2**2+(R2*B)**2))**2)))
    ,
          
    
        
    y2: lambda B,n1,n2,mu1,mu2:
    
    - ((-R1*B)/(rho1**2+(R1*B)**2) + (-R2*B)/(rho2**2+(R2*B)**2)) / 
    
  ((rho1 / (rho1**2 + (R1*B)**2) + rho2 / (rho2**2 + (R2*B)**2))**2
       
       + ((-R1*B)/(rho1**2+(R1*B)**2) + (-R2*B)/(rho2**2+(R2*B)**2))**2)
          
})

mixed_model = CallableNumericalModel(dictionary, 
                connectivity_mapping = {y1:{B,n_1,n_2,mu_1,mu_2}, 
                                       y2:{B,n_1,n_2,mu_1,mu_2}})

model_sim = mixed_model(B=xdata, n1=n1, n2=n2, mu1=mu1, mu2=mu2)

rho_xx_sim = model_sim.y1
rho_xy_sim = model_sim.y2

fit = Fit(mixed_model, B=xdata, y1=rho_xx_sim, y2=rho_xy_sim)
fit_result = fit.execute()
print(fit_result)
